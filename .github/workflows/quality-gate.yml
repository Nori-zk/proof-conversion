name: Quality Gate

on:
  pull_request:
    types: [opened, synchronize]
  push:
    branches:
      - develop

jobs:
  quality-check:
    name: quality-check
    runs-on: [self-hosted, nori, standard]
    permissions:
      contents: read
      pull-requests: write
      issues: write
    
    env:
      # Enable/disable checks
      CHECK_BUILD: true
      CHECK_SCRIPTS: true
      CHECK_AUDIT: true
      CHECK_PRETTIER: true
      CHECK_LINT: true
      CHECK_TEST_UNIT: true
      
      # Required vs optional (true = blocks merge)
      REQUIRE_BUILD: true
      REQUIRE_SCRIPTS: false
      REQUIRE_AUDIT: true
      REQUIRE_PRETTIER: false
      REQUIRE_LINT: false
      REQUIRE_TEST_UNIT: false
      
      # Tool dependencies
      PRETTIER_DEP: "prettier"
      LINT_DEP: "eslint"
      
      # Expected scripts
      EXPECT_SCRIPTS: "test:unit,test:integration,test:e2e"
      
      # Audit severity threshold
      AUDIT_LEVEL: "moderate"
    
    steps:
      - name: Fix workspace permissions
        run: |
          sudo chown -R runner:runner $GITHUB_WORKSPACE
          sudo chown -R runner:runner /home/runner/actions/_work/_tool

      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
        
      - name: Run Quality Gate and Post to PR
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');
            
            // Configuration
            const config = {
              checks: {
                build: { enabled: process.env.CHECK_BUILD === 'true', required: process.env.REQUIRE_BUILD === 'true' },
                scripts: { enabled: process.env.CHECK_SCRIPTS === 'true', required: process.env.REQUIRE_SCRIPTS === 'true' },
                audit: { enabled: process.env.CHECK_AUDIT === 'true', required: process.env.REQUIRE_AUDIT === 'true' },
                prettier: { enabled: process.env.CHECK_PRETTIER === 'true', required: process.env.REQUIRE_PRETTIER === 'true' },
                lint: { enabled: process.env.CHECK_LINT === 'true', required: process.env.REQUIRE_LINT === 'true' },
                testUnit: { enabled: process.env.CHECK_TEST_UNIT === 'true', required: process.env.REQUIRE_TEST_UNIT === 'true' }
              },
              prettierDep: process.env.PRETTIER_DEP || 'prettier',
              lintDep: process.env.LINT_DEP || 'eslint',
              expectScripts: (process.env.EXPECT_SCRIPTS || '').split(',').filter(Boolean),
              auditLevel: process.env.AUDIT_LEVEL || 'moderate'
            };
            
            // Results tracking
            const results = {
              timestamp: new Date().toISOString(),
              passed: 0,
              failed: 0,
              skipped: 0,
              hardFailures: [],
              sections: [],
              usedLegacyPeerDeps: false,
              installOutput: '',
              installSucceeded: false,
              hasDeprecationWarnings: false
            };
            
            // Helper functions
            function addPass(name, message, required) {
              results.passed++;
              results.sections.push({ name, status: 'PASS', type: required ? 'REQUIRED' : 'Optional', message });
              console.log(`✓ ${name}: PASS`);
            }
            
            function addFail(name, message, required, hint = '', details = '') {
              results.failed++;
              if (required) results.hardFailures.push(name);
              results.sections.push({ name, status: 'FAIL', type: required ? 'REQUIRED' : 'Optional', message, hint, details });
              console.log(`✗ ${name}: FAIL - ${message}`);
            }
            
            function addSkip(name, reason) {
              results.skipped++;
              results.sections.push({ name, status: 'SKIPPED', type: 'Info', message: reason });
              console.log(`○ ${name}: SKIPPED - ${reason}`);
            }
            
            function addWarning(name, message, hint = '', details = '') {
              results.sections.push({ name, status: 'WARNING', type: 'Warning', message, hint, details });
              console.log(`⚠ ${name}: WARNING - ${message}`);
            }
            
            function run(cmd) {
              try {
                const output = execSync(cmd, { encoding: 'utf8', stdio: 'pipe', maxBuffer: 10 * 1024 * 1024 });
                // Strip ANSI color codes
                return { success: true, output: output.replace(/\x1b\[[0-9;]*m/g, '') };
              } catch (error) {
                // Combine both stdout and stderr
                const stdout = error.stdout || '';
                const stderr = error.stderr || '';
                const combined = (stdout + '\n' + stderr).trim();
                // Strip ANSI color codes
                return { success: false, output: combined.replace(/\x1b\[[0-9;]*m/g, '') || error.message };
              }
            }
            
            function hasPackageJson() {
              return fs.existsSync('package.json');
            }
            
            function getPackageJson() {
              return JSON.parse(fs.readFileSync('package.json', 'utf8'));
            }
            
            function hasOverrides() {
              if (!hasPackageJson()) return false;
              const pkg = getPackageJson();
              return !!(pkg.overrides && Object.keys(pkg.overrides).length > 0);
            }
            
            console.log('========================================');
            console.log('Quality Gate Starting');
            console.log('========================================\n');
            
            // Install dependencies - try without legacy first, then with if needed
            console.log('Installing dependencies...');
            let installResult = run('npm ci');
            let firstAttemptOutput = '';
            
            if (!installResult.success) {
              firstAttemptOutput = installResult.output;
              console.log('Standard npm ci failed, trying with --legacy-peer-deps...');
              installResult = run('npm ci --legacy-peer-deps');
              
              if (installResult.success) {
                results.usedLegacyPeerDeps = true;
                results.installOutput = firstAttemptOutput;
                results.installSucceeded = true;
                
                // Check for deprecation warnings
                if (installResult.output.includes('deprecated')) {
                  results.hasDeprecationWarnings = true;
                }
                
                addWarning('Dependencies', 
                  'Dependencies installed with --legacy-peer-deps due to peer dependency conflicts', 
                  'Consider resolving peer dependencies to avoid using --legacy-peer-deps',
                  firstAttemptOutput);
                addPass('Dependencies', 'Dependencies installed successfully (with --legacy-peer-deps)', true);
              } else {
                results.installOutput = installResult.output;
                results.installSucceeded = false;
                addFail('Dependencies', 'npm ci failed even with --legacy-peer-deps', true, 
                  'Check npm error logs and resolve dependency conflicts', 
                  installResult.output);
              }
            } else {
              results.installOutput = installResult.output;
              results.installSucceeded = true;
              
              // Check for deprecation warnings
              if (installResult.output.includes('deprecated')) {
                results.hasDeprecationWarnings = true;
              }
              
              // Verify node_modules exists and has content
              if (!fs.existsSync('node_modules') || fs.readdirSync('node_modules').length === 0) {
                results.installSucceeded = false;
                addFail('Dependencies', 'npm ci reported success but node_modules is empty or missing', true, 
                  'This is unusual - check filesystem permissions and npm cache', 
                  installResult.output);
              } else {
                addPass('Dependencies', 'Dependencies installed successfully', true);
              }
            }
            
            // Check scripts
            if (config.checks.scripts.enabled) {
              if (!hasPackageJson()) {
                addSkip('Scripts Check', 'package.json not found');
              } else {
                const pkg = getPackageJson();
                const found = [];
                const missing = [];
                
                config.expectScripts.forEach(script => {
                  (pkg.scripts?.[script] ? found : missing).push(script);
                });
                
                if (missing.length === 0) {
                  addPass('Scripts Check', `All expected scripts present: ${found.join(', ')}`, config.checks.scripts.required);
                } else {
                  addFail('Scripts Check', `Missing scripts: ${missing.join(', ')}`, config.checks.scripts.required, '', 
                    `Expected: ${config.expectScripts.join(', ')}\nFound: ${found.join(', ')}\nMissing: ${missing.join(', ')}`);
                }
              }
            } else {
              addSkip('Scripts Check', 'Disabled via CHECK_SCRIPTS=false');
            }
            
            // Check npm audit
            if (config.checks.audit.enabled) {
              if (!hasPackageJson()) {
                addSkip('npm audit', 'package.json not found');
              } else {
                const result = run(`npm audit --audit-level=${config.auditLevel}`);
                
                if (result.success) {
                  addPass('npm audit', `No vulnerabilities found at ${config.auditLevel} level or above`, config.checks.audit.required);
                } else {
                  addFail('npm audit', `Vulnerabilities found (threshold: ${config.auditLevel})`, 
                    config.checks.audit.required, 'npm audit fix', result.output);
                }
              }
            } else {
              addSkip('npm audit', 'Disabled via CHECK_AUDIT=false');
            }
            
            // Check build
            if (config.checks.build.enabled) {
              if (!hasPackageJson()) {
                addSkip('Build', 'package.json not found');
              } else {
                const pkg = getPackageJson();
                if (!pkg.scripts?.build) {
                  addFail('Build', 'build script not found in package.json', config.checks.build.required);
                } else {
                  const result = run('npm run build');
                  if (result.success) {
                    addPass('Build', 'Build completed successfully', config.checks.build.required);
                  } else {
                    // ALWAYS include install output when build fails
                    let buildDetails = '=== Build Error ===\n' + result.output;
                    buildDetails += '\n\n=== npm ci output ===\n';
                    if (results.usedLegacyPeerDeps) {
                      buildDetails += '(Standard npm ci failed, had to use --legacy-peer-deps)\n\n';
                      buildDetails += 'Standard npm ci error:\n' + results.installOutput;
                    } else if (results.installSucceeded) {
                      buildDetails += results.installOutput;
                    } else {
                      buildDetails += '(npm ci failed completely - see Dependencies failure above)';
                    }
                    addFail('Build', 'Build failed', config.checks.build.required, 'Check build errors and npm install output', buildDetails);
                  }
                }
              }
            } else {
              addSkip('Build', 'Disabled via CHECK_BUILD=false');
            }
            
            // Check prettier
            if (config.checks.prettier.enabled) {
              if (!hasPackageJson()) {
                addSkip('Prettier', 'package.json not found');
              } else {
                const pkg = getPackageJson();
                const hasDep = pkg.dependencies?.[config.prettierDep] || pkg.devDependencies?.[config.prettierDep];
                
                if (!hasDep) {
                  if (config.checks.prettier.required) {
                    addFail('Prettier', `${config.prettierDep} not installed`, config.checks.prettier.required, 
                      `npm install --save-dev ${config.prettierDep}`);
                  } else {
                    addSkip('Prettier', `${config.prettierDep} not installed`);
                  }
                } else {
                  const result = run('npx prettier --check "**/*.{ts,js,json,md}" --ignore-path .gitignore');
                  if (result.success) {
                    addPass('Prettier', 'All files properly formatted', config.checks.prettier.required);
                  } else {
                    const fileCount = result.output.split('\n').filter(l => l.trim() && !l.includes('Checking formatting')).length;
                    if (fileCount === 0) {
                      addPass('Prettier', 'All files properly formatted', config.checks.prettier.required);
                    } else {
                      addFail('Prettier', `${fileCount} file(s) need formatting`, config.checks.prettier.required, 'npm run format');
                    }
                  }
                }
              }
            } else {
              addSkip('Prettier', 'Disabled via CHECK_PRETTIER=false');
            }
            
            // Check linter
            if (config.checks.lint.enabled) {
              if (!hasPackageJson()) {
                addSkip('Linter', 'package.json not found');
              } else {
                const pkg = getPackageJson();
                const hasDep = pkg.dependencies?.[config.lintDep] || pkg.devDependencies?.[config.lintDep];
                
                if (!hasDep) {
                  if (config.checks.lint.required) {
                    addFail('Linter', `${config.lintDep} not installed`, config.checks.lint.required, 
                      `npm install --save-dev ${config.lintDep}`);
                  } else {
                    addSkip('Linter', `${config.lintDep} not installed`);
                  }
                } else if (!pkg.scripts?.lint) {
                  addSkip('Linter', 'lint script not found in package.json');
                } else {
                  const result = run('npm run lint');
                  if (result.success) {
                    addPass('Linter', 'No linting errors', config.checks.lint.required);
                  } else {
                    const errorMatch = result.output.match(/(\d+)\s+error/);
                    const warningMatch = result.output.match(/(\d+)\s+warning/);
                    const errors = errorMatch ? parseInt(errorMatch[1]) : 0;
                    const warnings = warningMatch ? parseInt(warningMatch[1]) : 0;
                    
                    if (errors === 0 && warnings === 0) {
                      addPass('Linter', 'No linting errors', config.checks.lint.required);
                    } else {
                      addFail('Linter', `${errors} error(s), ${warnings} warning(s)`, config.checks.lint.required, 
                        'npm run lint', result.output);
                    }
                  }
                }
              }
            } else {
              addSkip('Linter', 'Disabled via CHECK_LINT=false');
            }
            
            // Check unit Tests
            if (config.checks.testUnit.enabled) {
              if (!hasPackageJson()) {
                addSkip('Unit Tests', 'package.json not found');
              } else {
                const pkg = getPackageJson();
                if (!pkg.scripts?.['test:unit']) {
                  addSkip('Unit Tests', 'test:unit script not found');
                } else {
                  const result = run('npm run test:unit');
                  if (result.success) {
                    addPass('Unit Tests', 'All unit tests passed', config.checks.testUnit.required);
                  } else {
                    addFail('Unit Tests', 'Unit tests failed', config.checks.testUnit.required, 
                      'Check test output', result.output);
                  }
                }
              }
            } else {
              addSkip('Unit Tests', 'Disabled via CHECK_TEST_UNIT=false');
            }
            
            // Generate summary
            console.log('\n========================================');
            console.log('Quality Gate Complete');
            console.log('========================================');
            console.log(`Passed: ${results.passed}`);
            console.log(`Failed: ${results.failed}`);
            console.log(`Skipped: ${results.skipped}`);
            
            // Build markdown report
            let report = `# Quality Gate Report\n\n**Generated:** ${new Date(results.timestamp).toLocaleString()}\n\n`;
            
            if (results.hardFailures.length === 0) {
              report += '## Overall Status: PASS\n\n';
              if (results.failed > 0) {
                report += `**Warnings:** ${results.failed} optional check(s) failed\n\n`;
              }
            } else {
              report += '## Overall Status: FAIL\n\n**Required checks failed:**\n';
              results.hardFailures.forEach(f => report += `- ${f}\n`);
              report += '\n';
            }
            
            report += `---\n\n## Summary\n\n- **Passed:** ${results.passed}\n- **Failed:** ${results.failed}\n- **Skipped:** ${results.skipped}\n\n---\n\n## Detailed Results\n\n`;
            
            results.sections.forEach(section => {
              report += `### ${section.name} - ${section.status}\n\n**Type:** ${section.type}\n\n**Message:** ${section.message}\n\n`;
              if (section.hint) report += `**Hint:** \`${section.hint}\`\n\n`;
              if (section.details) report += `<details>\n<summary>Details</summary>\n\n\`\`\`\n${section.details}\n\`\`\`\n\n</details>\n\n`;
            });
            
            // Generate actionable insights
            const insights = [];
            
            // Check for deprecation warnings
            if (results.hasDeprecationWarnings && results.installSucceeded) {
              insights.push(`**Deprecation Warnings:** Some installed packages are deprecated. Review the npm install output above and consider updating to maintained alternatives.`);
            }
            
            // Check for legacy peer deps usage
            if (results.usedLegacyPeerDeps) {
              insights.push(`**Peer Dependency Conflicts:** Dependencies required \`--legacy-peer-deps\` to install. This indicates peer dependency version conflicts.`);
              
              if (hasOverrides()) {
                insights.push(`**Overrides Detected:** Your package.json contains dependency overrides. When using --legacy-peer-deps with overrides, you should aim to remove the overrides when possible by updating dependencies to compatible versions.`);
              } else {
                insights.push(`**Resolve Peer Dependencies:** Update dependencies to compatible versions: \`npm update\` and check for breaking changes. Consider using \`npm ls <package-name>\` to identify conflict sources.`);
              }
            }
            
            results.sections.forEach(section => {
              if (section.status === 'FAIL') {
                if (section.name === 'Dependencies' && section.message.includes('failed even with')) {
                  insights.push(`**Critical:** Dependencies cannot be installed. Check error details above and resolve package.json issues or network problems.`);
                } else if (section.name === 'Dependencies' && section.message.includes('node_modules is empty')) {
                  insights.push(`**Critical:** npm ci succeeded but node_modules is missing. Check filesystem permissions and npm cache integrity.`);
                } else if (section.name === 'Prettier' && section.message.includes('not installed')) {
                  insights.push(`Install formatter: \`npm install --save-dev ${config.prettierDep}\``);
                } else if (section.name === 'Linter' && section.message.includes('not installed')) {
                  insights.push(`Install linter: \`npm install --save-dev ${config.lintDep}\``);
                } else if (section.name === 'Prettier' && section.message.includes('need formatting')) {
                  insights.push(`Auto-fix formatting: \`npx ${config.prettierDep} --write "**/*.{ts,js,json,md}"\``);
                } else if (section.name === 'npm audit' && section.message.includes('Vulnerabilities')) {
                  insights.push(`**Fix Vulnerabilities:** \`npm audit fix\` (or \`npm audit fix --force\` for breaking changes)`);
                } else if (section.name === 'Build' && section.message.includes('not found')) {
                  insights.push(`Add build script to package.json: \`"build": "tsc"\` or appropriate build command`);
                } else if (section.name === 'Build' && section.message.includes('Build failed')) {
                  insights.push(`**Build Failed:** Check the build error details above. Fix the errors shown in the build output and run \`npm run build\` locally to verify.`);
                } else if (section.name === 'Linter' && section.message.match(/\d+ error/)) {
                  insights.push(`**Linting Errors:** Fix the linting errors shown above and run \`npm run lint\` locally to verify.`);
                } else if (section.name === 'Unit Tests' && section.message.includes('failed')) {
                  insights.push(`**Unit Tests Failed:** Fix the failing tests shown above and run \`npm run test:unit\` locally to verify.`);
                } else if (section.name === 'Scripts Check' && section.message.includes('Missing')) {
                  const missing = section.details?.match(/Missing: (.+)/)?.[1];
                  const pkg = hasPackageJson() ? getPackageJson() : null;
                  const hasBaseTest = pkg?.scripts?.test;
                  
                  if (missing && !hasBaseTest) {
                    insights.push(`Add base test script first: \`"test": "node --experimental-vm-modules node_modules/jest/bin/jest.js --forceExit --"\` (adjust for your test runner)`);
                  }
                  
                  if (missing?.includes('test:unit')) {
                    insights.push(`Add unit tests: \`"test:unit": "for file in $(find . -name '*.unit.spec.ts'); do npm run test -- \\"$file\\" || exit 1; done"\``);
                  }
                  if (missing?.includes('test:integration')) {
                    insights.push(`Add integration tests: \`"test:integration": "for file in $(find . -name '*.integration.spec.ts'); do npm run test -- \\"$file\\" || exit 1; done"\``);
                  }
                  if (missing?.includes('test:e2e')) {
                    insights.push(`Add E2E tests: \`"test:e2e": "for file in $(find . -name '*.e2e.spec.ts'); do npm run test -- \\"$file\\" || exit 1; done"\``);
                  }
                }
              } else if (section.status === 'SKIPPED' && section.name === 'Linter' && section.message.includes('lint script not found')) {
                insights.push(`Add lint script to package.json (adjust for your linter): \`"lint": "${config.lintDep} ."\``);
              }
            });
            
            if (insights.length > 0) {
              report += `---\n\n## Actionable Insights\n\n`;
              insights.forEach(insight => report += `- ${insight}\n`);
              report += '\n';
            }
            
            report += `---\n\n## Configuration\n\nQuality gate configured via environment variables.\n\n`;
            report += `| Check | Enabled | Required |\n|-------|---------|----------|\n`;
            report += `| Dependencies | true | true |\n`;
            report += `| Build | ${config.checks.build.enabled} | ${config.checks.build.required} |\n`;
            report += `| Scripts | ${config.checks.scripts.enabled} | ${config.checks.scripts.required} |\n`;
            report += `| npm audit | ${config.checks.audit.enabled} | ${config.checks.audit.required} (level: ${config.auditLevel}) |\n`;
            report += `| Prettier | ${config.checks.prettier.enabled} | ${config.checks.prettier.required} (dep: ${config.prettierDep}) |\n`;
            report += `| Linter | ${config.checks.lint.enabled} | ${config.checks.lint.required} (dep: ${config.lintDep}) |\n`;
            report += `| Unit Tests | ${config.checks.testUnit.enabled} | ${config.checks.testUnit.required} |\n\n`;
            report += `**Note:** Integration and E2E tests are checked for existence but run in CI/CD pipeline.\n`;
            
            // Always write to GitHub Actions Job Summary (visible in the Actions tab)
            fs.appendFileSync(process.env.GITHUB_STEP_SUMMARY, report);
            console.log('Quality gate report written to job summary');
            
            // Additionally, try to post as PR comment if this is a PR
            if (context.issue.number) {
              try {
                await github.rest.issues.createComment({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: report
                });
                console.log('Posted quality gate comment to PR');
              } catch (error) {
                console.log('Failed to post PR comment (likely fork PR with read-only token):', error.message);
              }
            }
            
            // Fail if required checks failed
            if (results.hardFailures.length > 0) {
              console.log('\nOVERALL: FAIL');
              console.log('Required checks failed:', results.hardFailures.join(', '));
              process.exit(1);
            } else {
              console.log('\nOVERALL: PASS');
            }